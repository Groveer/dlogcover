<!-- Generated by SpecStory -->

# 项目工程生成与需求标记 (2025-05-15 08:59:23)

_**User**_

基于架构设计文档，生成项目工程，完成的需求在产品需求文档中标记

---

_**Assistant**_



---

# Mode: PLAN

我需要了解当前项目的状态和需求，然后帮助您生成项目工程。让我首先查看项目目录结构。

---

<details>
            <summary>Listed current directory • **5** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `README.md` |
| 📁 `docs` |
| 📁 `.cursor` |
| 📄 `LICENSE` |

</details>

---

让我首先查看README.md文件以了解项目基本情况：

---

Read file: README.md

---

接下来查看文档目录，特别是架构设计文档和产品需求文档：

---

<details>
            <summary>Listed directory docs • **4** results</summary>
        
| Name |
|-------|
| 📄 `产品需求文档.md` |
| 📄 `详细设计文档.md` |
| 📄 `概要设计文档.md` |
| 📄 `架构设计文档.md` |

</details>

---

让我先查看架构设计文档，了解系统的整体架构：

---

Read file: docs/架构设计文档.md

---

让我继续阅读架构设计文档的其余部分：

---

Read file: docs/架构设计文档.md

---

现在让我查看产品需求文档，了解需要实现的功能需求：

---

Read file: docs/产品需求文档.md

---

让我查看概要设计文档，了解更多系统设计细节：

---

Read file: docs/概要设计文档.md

---

现在我已经对项目有了一个基本的了解，我可以开始设计实施计划了。让我总结一下我从文档中获得的主要信息：

1. DLogCover是一个基于AST的C++日志覆盖率分析工具
2. 核心功能包括：
   - 命令行支持，可以指定扫描目录、输出目录等
   - 代码分析，支持扫描C++项目并识别日志函数
   - 覆盖率分析，包括函数级、分支级和异常处理级等
   - 报告生成，输出分析结果和建议

3. 技术选型包括：
   - 开发语言：Modern C++ (C++17)
   - 静态分析：Clang/LLVM LibTooling
   - 配置文件格式：JSON
   - 命令行解析：CLI11/Boost Program Options
   - 文件操作：C++17 std::filesystem
   - 单元测试：GoogleTest

4. 系统架构分为多个层次：
   - 命令行接口层
   - 配置管理层
   - 源文件管理层
   - AST分析层
   - 日志识别层
   - 覆盖率计算层
   - 报告生成层

让我制定一个实施计划，根据架构设计文档创建项目结构并实现基础功能。

## 实施计划

1. 创建项目基本结构，包括目录结构和CMake构建系统
2. 实现命令行接口层与配置管理层
3. 实现源文件管理层
4. 实现AST分析层与日志识别层
5. 实现覆盖率计算层
6. 实现报告生成层
7. 编写测试和示例

下面我将按照这个计划开始实施。

第一步，我需要创建项目的基本目录结构和CMake配置文件：

---

```bash
mkdir -p src/cli src/config src/source_manager src/core/ast_analyzer src/core/log_identifier src/core/coverage src/utils src/reporter include/dlogcover tests/unit tests/integration examples third_party
```

```
ut000520@wangbo:/data/workspace/git/dlogcover|main ⇒  

```

---

接下来，让我创建项目的主CMake配置文件：

---

```diff
- 
+ cmake_minimum_required(VERSION 3.10)
+ project(dlogcover VERSION 0.1.0 LANGUAGES CXX)
+ 
+ # 设置C++标准
+ set(CMAKE_CXX_STANDARD 17)
+ set(CMAKE_CXX_STANDARD_REQUIRED ON)
+ set(CMAKE_CXX_EXTENSIONS OFF)
+ 
+ # 设置输出目录
+ set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+ set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+ set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+ 
+ # 包含目录
+ include_directories(
+     ${CMAKE_CURRENT_SOURCE_DIR}/include
+     ${CMAKE_CURRENT_SOURCE_DIR}/third_party
+ )
+ 
+ # 设置编译选项
+ if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
+     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -pedantic")
+     set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -O0")
+     set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3")
+ endif()
+ 
+ # 检查LLVM依赖
+ find_package(LLVM REQUIRED CONFIG)
+ message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
+ message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")
+ 
+ # 添加LLVM头文件和定义
+ include_directories(${LLVM_INCLUDE_DIRS})
+ add_definitions(${LLVM_DEFINITIONS})
+ 
+ # 检查Clang依赖
+ find_package(Clang REQUIRED CONFIG)
+ message(STATUS "Found Clang ${CLANG_PACKAGE_VERSION}")
+ message(STATUS "Using ClangConfig.cmake in: ${Clang_DIR}")
+ 
+ # 添加Clang头文件
+ include_directories(${CLANG_INCLUDE_DIRS})
+ 
+ # 添加源文件
+ add_subdirectory(src)
+ 
+ # 添加单元测试
+ option(BUILD_TESTS "Build the tests" OFF)
+ if(BUILD_TESTS)
+     enable_testing()
+     add_subdirectory(tests)
+ endif()
+ 
+ # 安装规则
+ install(TARGETS dlogcover
+     RUNTIME DESTINATION bin
+ )
+ 
+ # 安装示例配置文件
+ install(FILES example/dlogcover.json
+     DESTINATION share/dlogcover
+ )
+ 
+ # 包信息
+ set(CPACK_PACKAGE_NAME "dlogcover")
+ set(CPACK_PACKAGE_VERSION ${PROJECT_VERSION})
+ set(CPACK_PACKAGE_VENDOR "DLogCover Team")
+ set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "C++ Log Coverage Analysis Tool")
+ set(CPACK_PACKAGE_DESCRIPTION "A tool for analyzing log coverage in C++ projects")
+ set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
+ include(CPack) 
```

---

现在让我创建src/CMakeLists.txt文件，用于构建源代码：

---

```diff
- 
+ # 添加子目录
+ add_subdirectory(cli)
+ add_subdirectory(config)
+ add_subdirectory(source_manager)
+ add_subdirectory(core)
+ add_subdirectory(reporter)
+ add_subdirectory(utils)
+ 
+ # 设置源文件列表
+ set(DLOGCOVER_SOURCES
+     main.cpp
+ )
+ 
+ # 创建可执行文件
+ add_executable(dlogcover ${DLOGCOVER_SOURCES})
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover
+     PRIVATE
+     dlogcover_cli
+     dlogcover_config
+     dlogcover_source_manager
+     dlogcover_core
+     dlogcover_reporter
+     dlogcover_utils
+     ${LLVM_AVAILABLE_LIBS}
+     clangTooling
+     clangBasic
+     clangASTMatchers
+     clangAST
+     clangFrontend
+ ) 
```

---

创建src/core的CMakeLists.txt文件，处理子目录构建：

---

```diff
- 
+ # 添加子目录
+ add_subdirectory(ast_analyzer)
+ add_subdirectory(log_identifier)
+ add_subdirectory(coverage)
+ 
+ # 创建core目标库
+ add_library(dlogcover_core INTERFACE)
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_core
+     INTERFACE
+     dlogcover_ast_analyzer
+     dlogcover_log_identifier
+     dlogcover_coverage
+ ) 
```

---

接下来创建各个子模块的CMakeLists.txt文件：

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_CLI_SOURCES
+     command_line_parser.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_CLI_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/cli/command_line_parser.h
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/cli/options.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_cli STATIC
+     ${DLOGCOVER_CLI_SOURCES}
+     ${DLOGCOVER_CLI_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_cli
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ )
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_cli
+     PUBLIC
+     dlogcover_utils
+ ) 
```

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_CONFIG_SOURCES
+     config_manager.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_CONFIG_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/config/config_manager.h
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/config/config.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_config STATIC
+     ${DLOGCOVER_CONFIG_SOURCES}
+     ${DLOGCOVER_CONFIG_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_config
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ )
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_config
+     PUBLIC
+     dlogcover_utils
+ ) 
```

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_SOURCE_MANAGER_SOURCES
+     source_manager.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_SOURCE_MANAGER_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/source_manager/source_manager.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_source_manager STATIC
+     ${DLOGCOVER_SOURCE_MANAGER_SOURCES}
+     ${DLOGCOVER_SOURCE_MANAGER_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_source_manager
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ )
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_source_manager
+     PUBLIC
+     dlogcover_utils
+     dlogcover_config
+ ) 
```

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_AST_ANALYZER_SOURCES
+     ast_analyzer.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_AST_ANALYZER_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/core/ast_analyzer/ast_analyzer.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_ast_analyzer STATIC
+     ${DLOGCOVER_AST_ANALYZER_SOURCES}
+     ${DLOGCOVER_AST_ANALYZER_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_ast_analyzer
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ )
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_ast_analyzer
+     PUBLIC
+     dlogcover_utils
+     dlogcover_config
+     ${LLVM_AVAILABLE_LIBS}
+     clangTooling
+     clangBasic
+     clangASTMatchers
+     clangAST
+     clangFrontend
+ ) 
```

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_LOG_IDENTIFIER_SOURCES
+     log_identifier.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_LOG_IDENTIFIER_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/core/log_identifier/log_identifier.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_log_identifier STATIC
+     ${DLOGCOVER_LOG_IDENTIFIER_SOURCES}
+     ${DLOGCOVER_LOG_IDENTIFIER_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_log_identifier
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ )
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_log_identifier
+     PUBLIC
+     dlogcover_utils
+     dlogcover_config
+     dlogcover_ast_analyzer
+ ) 
```

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_COVERAGE_SOURCES
+     coverage_calculator.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_COVERAGE_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/core/coverage/coverage_calculator.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_coverage STATIC
+     ${DLOGCOVER_COVERAGE_SOURCES}
+     ${DLOGCOVER_COVERAGE_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_coverage
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ )
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_coverage
+     PUBLIC
+     dlogcover_utils
+     dlogcover_config
+     dlogcover_log_identifier
+ ) 
```

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_REPORTER_SOURCES
+     reporter.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_REPORTER_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/reporter/reporter.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_reporter STATIC
+     ${DLOGCOVER_REPORTER_SOURCES}
+     ${DLOGCOVER_REPORTER_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_reporter
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ )
+ 
+ # 链接依赖库
+ target_link_libraries(dlogcover_reporter
+     PUBLIC
+     dlogcover_utils
+     dlogcover_config
+     dlogcover_core
+ ) 
```

---

```diff
- 
+ # 设置源文件
+ set(DLOGCOVER_UTILS_SOURCES
+     file_utils.cpp
+     string_utils.cpp
+     log_utils.cpp
+ )
+ 
+ # 设置头文件
+ set(DLOGCOVER_UTILS_HEADERS
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/utils/file_utils.h
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/utils/string_utils.h
+     ${CMAKE_SOURCE_DIR}/include/dlogcover/utils/log_utils.h
+ )
+ 
+ # 创建库
+ add_library(dlogcover_utils STATIC
+     ${DLOGCOVER_UTILS_SOURCES}
+     ${DLOGCOVER_UTILS_HEADERS}
+ )
+ 
+ # 指定包含目录
+ target_include_directories(dlogcover_utils
+     PUBLIC
+     ${CMAKE_SOURCE_DIR}/include
+ ) 
```

---

现在，让我开始创建必要的头文件，首先是用于命令行参数解析的头文件：

---

```bash
mkdir -p include/dlogcover/cli include/dlogcover/config include/dlogcover/source_manager include/dlogcover/core/ast_analyzer include/dlogcover/core/log_identifier include/dlogcover/core/coverage include/dlogcover/utils include/dlogcover/reporter
```

```
ut000520@wangbo:/data/workspace/git/dlogcover|main ⇒  

```

---

创建命令行接口相关的头文件：

---

```diff
- 
+ /**
+  * @file options.h
+  * @brief 命令行选项定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_CLI_OPTIONS_H
+ #define DLOGCOVER_CLI_OPTIONS_H
+ 
+ #include <string>
+ #include <vector>
+ 
+ namespace dlogcover {
+ namespace cli {
+ 
+ /**
+  * @brief 日志级别枚举
+  */
+ enum class LogLevel {
+     DEBUG,    ///< 调试级别
+     INFO,     ///< 信息级别
+     WARNING,  ///< 警告级别
+     CRITICAL, ///< 严重级别
+     FATAL,    ///< 致命级别
+     ALL       ///< 所有级别
+ };
+ 
+ /**
+  * @brief 报告格式枚举
+  */
+ enum class ReportFormat {
+     TEXT, ///< 文本格式
+     JSON  ///< JSON格式
+ };
+ 
+ /**
+  * @brief 命令行选项结构体
+  */
+ struct Options {
+     std::string directoryPath;               ///< 扫描目录路径
+     std::string outputPath;                  ///< 输出报告路径
+     std::string configPath;                  ///< 配置文件路径
+     std::vector<std::string> excludePatterns; ///< 排除模式列表
+     LogLevel logLevel = LogLevel::ALL;       ///< 日志级别
+     ReportFormat reportFormat = ReportFormat::TEXT; ///< 报告格式
+ 
+     /**
+      * @brief 验证选项是否有效
+      * @return 有效返回true，否则返回false
+      */
+     bool isValid() const;
+ };
+ 
+ } // namespace cli
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_CLI_OPTIONS_H 
```

---

```diff
- 
+ /**
+  * @file command_line_parser.h
+  * @brief 命令行解析器定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_CLI_COMMAND_LINE_PARSER_H
+ #define DLOGCOVER_CLI_COMMAND_LINE_PARSER_H
+ 
+ #include <dlogcover/cli/options.h>
+ 
+ namespace dlogcover {
+ namespace cli {
+ 
+ /**
+  * @brief 命令行解析器类
+  */
+ class CommandLineParser {
+ public:
+     /**
+      * @brief 构造函数
+      */
+     CommandLineParser();
+ 
+     /**
+      * @brief 析构函数
+      */
+     ~CommandLineParser();
+ 
+     /**
+      * @brief 解析命令行参数
+      * @param argc 参数数量
+      * @param argv 参数数组
+      * @return 解析成功返回true，否则返回false
+      */
+     bool parse(int argc, char** argv);
+ 
+     /**
+      * @brief 显示帮助信息
+      */
+     void showHelp() const;
+ 
+     /**
+      * @brief 显示版本信息
+      */
+     void showVersion() const;
+ 
+     /**
+      * @brief 获取解析后的选项
+      * @return 命令行选项
+      */
+     const Options& getOptions() const;
+ 
+ private:
+     Options options_; ///< 命令行选项
+ };
+ 
+ } // namespace cli
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_CLI_COMMAND_LINE_PARSER_H 
```

---

创建配置管理相关的头文件：

---

Cancelled

---

_**User**_

继续

---

_**Assistant**_



---

# Mode: PLAN

我将继续为DLogCover项目创建必要的头文件和源文件。接下来我需要创建配置管理相关的头文件，然后逐步实现其他模块。

让我创建配置管理相关的头文件：

---

```diff
- 
+ /**
+  * @file config.h
+  * @brief 配置定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_CONFIG_CONFIG_H
+ #define DLOGCOVER_CONFIG_CONFIG_H
+ 
+ #include <string>
+ #include <vector>
+ #include <map>
+ #include <unordered_map>
+ 
+ namespace dlogcover {
+ namespace config {
+ 
+ /**
+  * @brief 扫描配置结构体
+  */
+ struct ScanConfig {
+     std::vector<std::string> directories;  ///< 扫描目录列表
+     std::vector<std::string> excludes;     ///< 排除目录列表
+     std::vector<std::string> fileTypes;    ///< 文件类型列表
+ };
+ 
+ /**
+  * @brief 日志函数配置-Qt
+  */
+ struct QtLogFunctionConfig {
+     bool enabled = true;                         ///< 是否启用
+     std::vector<std::string> functions;          ///< 函数列表
+     std::vector<std::string> categoryFunctions;  ///< 分类函数列表
+ };
+ 
+ /**
+  * @brief 日志函数配置-自定义
+  */
+ struct CustomLogFunctionConfig {
+     bool enabled = true;                                      ///< 是否启用
+     std::unordered_map<std::string, std::vector<std::string>> functions;  ///< 函数列表(级别=>函数名)
+ };
+ 
+ /**
+  * @brief 日志函数配置
+  */
+ struct LogFunctionsConfig {
+     QtLogFunctionConfig qt;           ///< Qt日志函数配置
+     CustomLogFunctionConfig custom;   ///< 自定义日志函数配置
+ };
+ 
+ /**
+  * @brief 分析配置
+  */
+ struct AnalysisConfig {
+     bool functionCoverage = true;     ///< 函数级覆盖率
+     bool branchCoverage = true;       ///< 分支覆盖率
+     bool exceptionCoverage = true;    ///< 异常覆盖率
+     bool keyPathCoverage = true;      ///< 关键路径覆盖率
+ };
+ 
+ /**
+  * @brief 报告配置
+  */
+ struct ReportConfig {
+     std::string format = "text";              ///< 格式(text, json)
+     std::string timestampFormat = "YYYYMMDD_HHMMSS";  ///< 时间戳格式
+ };
+ 
+ /**
+  * @brief 配置结构体
+  */
+ struct Config {
+     ScanConfig scan;                 ///< 扫描配置
+     LogFunctionsConfig logFunctions; ///< 日志函数配置
+     AnalysisConfig analysis;         ///< 分析配置
+     ReportConfig report;             ///< 报告配置
+ };
+ 
+ } // namespace config
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_CONFIG_CONFIG_H 
```

---

```diff
- 
+ /**
+  * @file config_manager.h
+  * @brief 配置管理器定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_CONFIG_CONFIG_MANAGER_H
+ #define DLOGCOVER_CONFIG_CONFIG_MANAGER_H
+ 
+ #include <string>
+ #include <dlogcover/config/config.h>
+ #include <dlogcover/cli/options.h>
+ 
+ namespace dlogcover {
+ namespace config {
+ 
+ /**
+  * @brief 配置管理器类
+  */
+ class ConfigManager {
+ public:
+     /**
+      * @brief 构造函数
+      */
+     ConfigManager();
+ 
+     /**
+      * @brief 析构函数
+      */
+     ~ConfigManager();
+ 
+     /**
+      * @brief 加载配置文件
+      * @param path 配置文件路径
+      * @return 加载成功返回true，否则返回false
+      */
+     bool loadConfig(const std::string& path);
+ 
+     /**
+      * @brief 与命令行选项合并
+      * @param options 命令行选项
+      */
+     void mergeWithCommandLineOptions(const cli::Options& options);
+ 
+     /**
+      * @brief 获取配置
+      * @return 配置
+      */
+     const Config& getConfig() const;
+ 
+     /**
+      * @brief 获取默认配置
+      * @return 默认配置
+      */
+     static Config getDefaultConfig();
+ 
+     /**
+      * @brief 验证配置
+      * @return 配置有效返回true，否则返回false
+      */
+     bool validateConfig() const;
+ 
+ private:
+     Config config_; ///< 配置
+ };
+ 
+ } // namespace config
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_CONFIG_CONFIG_MANAGER_H 
```

---

现在创建源文件管理模块的头文件：

---

```diff
- 
+ /**
+  * @file source_manager.h
+  * @brief 源文件管理器定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_SOURCE_MANAGER_SOURCE_MANAGER_H
+ #define DLOGCOVER_SOURCE_MANAGER_SOURCE_MANAGER_H
+ 
+ #include <string>
+ #include <vector>
+ #include <unordered_map>
+ #include <dlogcover/config/config.h>
+ 
+ namespace dlogcover {
+ namespace source_manager {
+ 
+ /**
+  * @brief 源文件信息结构体
+  */
+ struct SourceFileInfo {
+     std::string path;            ///< 文件路径
+     std::string relativePath;    ///< 相对路径
+     std::string content;         ///< 文件内容
+     size_t size;                 ///< 文件大小
+     bool isHeader;               ///< 是否为头文件
+ };
+ 
+ /**
+  * @brief 源文件管理器类
+  */
+ class SourceManager {
+ public:
+     /**
+      * @brief 构造函数
+      * @param config 配置
+      */
+     explicit SourceManager(const config::Config& config);
+ 
+     /**
+      * @brief 析构函数
+      */
+     ~SourceManager();
+ 
+     /**
+      * @brief 收集源文件
+      * @return 成功返回true，否则返回false
+      */
+     bool collectSourceFiles();
+ 
+     /**
+      * @brief 获取源文件列表
+      * @return 源文件列表
+      */
+     const std::vector<SourceFileInfo>& getSourceFiles() const;
+ 
+     /**
+      * @brief 获取源文件数量
+      * @return 源文件数量
+      */
+     size_t getSourceFileCount() const;
+ 
+     /**
+      * @brief 根据路径获取源文件
+      * @param path 文件路径
+      * @return 源文件信息指针，如果不存在则返回nullptr
+      */
+     const SourceFileInfo* getSourceFile(const std::string& path) const;
+ 
+ private:
+     /**
+      * @brief 检查文件是否应该被排除
+      * @param path 文件路径
+      * @return 应该排除返回true，否则返回false
+      */
+     bool shouldExclude(const std::string& path) const;
+ 
+     /**
+      * @brief 是否为支持的文件类型
+      * @param path 文件路径
+      * @return 支持返回true，否则返回false
+      */
+     bool isSupportedFileType(const std::string& path) const;
+ 
+     /**
+      * @brief 读取文件内容
+      * @param path 文件路径
+      * @param content 输出内容
+      * @return 成功返回true，否则返回false
+      */
+     bool readFileContent(const std::string& path, std::string& content) const;
+ 
+     const config::Config& config_;   ///< 配置
+     std::vector<SourceFileInfo> sourceFiles_;   ///< 源文件列表
+     std::unordered_map<std::string, size_t> pathToIndex_;  ///< 路径到索引的映射
+ };
+ 
+ } // namespace source_manager
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_SOURCE_MANAGER_SOURCE_MANAGER_H 
```

---

现在创建AST分析器模块的头文件：

---

```diff
- 
+ /**
+  * @file ast_analyzer.h
+  * @brief AST分析器定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_CORE_AST_ANALYZER_AST_ANALYZER_H
+ #define DLOGCOVER_CORE_AST_ANALYZER_AST_ANALYZER_H
+ 
+ #include <string>
+ #include <vector>
+ #include <memory>
+ #include <unordered_map>
+ #include <dlogcover/config/config.h>
+ #include <dlogcover/source_manager/source_manager.h>
+ 
+ // 前置声明
+ namespace clang {
+ class ASTContext;
+ class ASTUnit;
+ class Stmt;
+ class Decl;
+ class FunctionDecl;
+ class CXXMethodDecl;
+ class CallExpr;
+ class CompoundStmt;
+ class IfStmt;
+ class SwitchStmt;
+ class ForStmt;
+ class WhileStmt;
+ class DoStmt;
+ class CXXTryStmt;
+ class CXXCatchStmt;
+ }
+ 
+ namespace dlogcover {
+ namespace core {
+ namespace ast_analyzer {
+ 
+ /**
+  * @brief 节点类型枚举
+  */
+ enum class NodeType {
+     FUNCTION,       ///< 函数
+     METHOD,         ///< 方法
+     IF_STMT,        ///< if语句
+     ELSE_STMT,      ///< else语句
+     SWITCH_STMT,    ///< switch语句
+     CASE_STMT,      ///< case语句
+     FOR_STMT,       ///< for语句
+     WHILE_STMT,     ///< while语句
+     DO_STMT,        ///< do语句
+     TRY_STMT,       ///< try语句
+     CATCH_STMT,     ///< catch语句
+     CALL_EXPR,      ///< 函数调用表达式
+     LOG_CALL_EXPR   ///< 日志函数调用表达式
+ };
+ 
+ /**
+  * @brief 位置信息结构体
+  */
+ struct Location {
+     std::string filePath;  ///< 文件路径
+     unsigned int line;     ///< 行号
+     unsigned int column;   ///< 列号
+ };
+ 
+ /**
+  * @brief AST节点信息结构体
+  */
+ struct ASTNodeInfo {
+     NodeType type;              ///< 节点类型
+     Location location;          ///< 位置信息
+     std::string name;           ///< 名称
+     std::string text;           ///< 文本
+     bool hasLogging = false;    ///< 是否包含日志
+     
+     std::vector<std::unique_ptr<ASTNodeInfo>> children;  ///< 子节点
+ };
+ 
+ /**
+  * @brief AST分析器类
+  */
+ class ASTAnalyzer {
+ public:
+     /**
+      * @brief 构造函数
+      * @param config 配置
+      * @param sourceManager 源文件管理器
+      */
+     ASTAnalyzer(const config::Config& config, 
+                 const source_manager::SourceManager& sourceManager);
+ 
+     /**
+      * @brief 析构函数
+      */
+     ~ASTAnalyzer();
+ 
+     /**
+      * @brief 分析源文件
+      * @param filePath 文件路径
+      * @return 分析成功返回true，否则返回false
+      */
+     bool analyze(const std::string& filePath);
+ 
+     /**
+      * @brief 分析所有源文件
+      * @return 分析成功返回true，否则返回false
+      */
+     bool analyzeAll();
+ 
+     /**
+      * @brief 获取AST节点信息
+      * @param filePath 文件路径
+      * @return AST节点信息指针，如果不存在则返回nullptr
+      */
+     const ASTNodeInfo* getASTNodeInfo(const std::string& filePath) const;
+ 
+     /**
+      * @brief 获取所有AST节点信息
+      * @return AST节点信息映射表
+      */
+     const std::unordered_map<std::string, std::unique_ptr<ASTNodeInfo>>& 
+     getAllASTNodeInfo() const;
+ 
+ private:
+     /**
+      * @brief 创建AST单元
+      * @param filePath 文件路径
+      * @param content 文件内容
+      * @return AST单元指针，如果失败则返回nullptr
+      */
+     std::unique_ptr<clang::ASTUnit> createASTUnit(
+         const std::string& filePath, const std::string& content);
+ 
+     /**
+      * @brief 分析AST上下文
+      * @param context AST上下文
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeASTContext(
+         clang::ASTContext& context, const std::string& filePath);
+ 
+     /**
+      * @brief 分析函数声明
+      * @param decl 函数声明
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeFunctionDecl(
+         clang::FunctionDecl* decl, const std::string& filePath);
+ 
+     /**
+      * @brief 分析方法声明
+      * @param decl 方法声明
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeMethodDecl(
+         clang::CXXMethodDecl* decl, const std::string& filePath);
+ 
+     /**
+      * @brief 分析语句
+      * @param stmt 语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeStmt(
+         clang::Stmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析复合语句
+      * @param stmt 复合语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeCompoundStmt(
+         clang::CompoundStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析if语句
+      * @param stmt if语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeIfStmt(
+         clang::IfStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析switch语句
+      * @param stmt switch语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeSwitchStmt(
+         clang::SwitchStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析for语句
+      * @param stmt for语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeForStmt(
+         clang::ForStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析while语句
+      * @param stmt while语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeWhileStmt(
+         clang::WhileStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析do语句
+      * @param stmt do语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeDoStmt(
+         clang::DoStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析try语句
+      * @param stmt try语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeTryStmt(
+         clang::CXXTryStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析catch语句
+      * @param stmt catch语句
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeCatchStmt(
+         clang::CXXCatchStmt* stmt, const std::string& filePath);
+ 
+     /**
+      * @brief 分析函数调用表达式
+      * @param expr 函数调用表达式
+      * @param filePath 文件路径
+      * @return AST节点信息指针
+      */
+     std::unique_ptr<ASTNodeInfo> analyzeCallExpr(
+         clang::CallExpr* expr, const std::string& filePath);
+ 
+     /**
+      * @brief 检查是否为日志函数调用
+      * @param expr 函数调用表达式
+      * @return 是日志函数返回true，否则返回false
+      */
+     bool isLogFunctionCall(clang::CallExpr* expr) const;
+ 
+     const config::Config& config_;  ///< 配置
+     const source_manager::SourceManager& sourceManager_;  ///< 源文件管理器
+ 
+     std::unordered_map<std::string, std::unique_ptr<ASTNodeInfo>> astNodes_;  ///< AST节点映射表
+ };
+ 
+ } // namespace ast_analyzer
+ } // namespace core
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_CORE_AST_ANALYZER_AST_ANALYZER_H 
```

---

接下来创建日志识别器模块的头文件：

---

```diff
- 
+ /**
+  * @file log_identifier.h
+  * @brief 日志识别器定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_CORE_LOG_IDENTIFIER_LOG_IDENTIFIER_H
+ #define DLOGCOVER_CORE_LOG_IDENTIFIER_LOG_IDENTIFIER_H
+ 
+ #include <string>
+ #include <vector>
+ #include <memory>
+ #include <unordered_map>
+ #include <unordered_set>
+ #include <dlogcover/config/config.h>
+ #include <dlogcover/core/ast_analyzer/ast_analyzer.h>
+ 
+ namespace dlogcover {
+ namespace core {
+ namespace log_identifier {
+ 
+ /**
+  * @brief 日志级别枚举
+  */
+ enum class LogLevel {
+     DEBUG,    ///< 调试级别
+     INFO,     ///< 信息级别
+     WARNING,  ///< 警告级别
+     CRITICAL, ///< 严重级别
+     FATAL,    ///< 致命级别
+     UNKNOWN   ///< 未知级别
+ };
+ 
+ /**
+  * @brief 日志类型枚举
+  */
+ enum class LogType {
+     QT,       ///< Qt日志函数
+     CUSTOM,   ///< 自定义日志函数
+     UNKNOWN   ///< 未知类型
+ };
+ 
+ /**
+  * @brief 日志调用信息结构体
+  */
+ struct LogCallInfo {
+     std::string functionName;   ///< 函数名
+     LogLevel level;             ///< 日志级别
+     LogType type;               ///< 日志类型
+     ast_analyzer::Location location;  ///< 位置信息
+     std::string message;        ///< 日志消息(如果可提取)
+ };
+ 
+ /**
+  * @brief 日志识别器类
+  */
+ class LogIdentifier {
+ public:
+     /**
+      * @brief 构造函数
+      * @param config 配置
+      * @param astAnalyzer AST分析器
+      */
+     LogIdentifier(const config::Config& config, 
+                  const ast_analyzer::ASTAnalyzer& astAnalyzer);
+ 
+     /**
+      * @brief 析构函数
+      */
+     ~LogIdentifier();
+ 
+     /**
+      * @brief 识别日志函数调用
+      * @return 识别成功返回true，否则返回false
+      */
+     bool identifyLogCalls();
+ 
+     /**
+      * @brief 获取日志调用信息
+      * @param filePath 文件路径
+      * @return 日志调用信息列表
+      */
+     const std::vector<LogCallInfo>& getLogCalls(const std::string& filePath) const;
+ 
+     /**
+      * @brief 获取所有日志调用信息
+      * @return 日志调用信息映射表
+      */
+     const std::unordered_map<std::string, std::vector<LogCallInfo>>& 
+     getAllLogCalls() const;
+ 
+     /**
+      * @brief 获取日志函数名集合
+      * @return 日志函数名集合
+      */
+     const std::unordered_set<std::string>& getLogFunctionNames() const;
+ 
+ private:
+     /**
+      * @brief 构建日志函数名集合
+      */
+     void buildLogFunctionNameSet();
+ 
+     /**
+      * @brief 识别节点中的日志函数调用
+      * @param node AST节点信息
+      * @param filePath 文件路径
+      */
+     void identifyLogCallsInNode(const ast_analyzer::ASTNodeInfo* node, 
+                                const std::string& filePath);
+ 
+     /**
+      * @brief 获取日志级别
+      * @param functionName 函数名
+      * @return 日志级别
+      */
+     LogLevel getLogLevel(const std::string& functionName) const;
+ 
+     /**
+      * @brief 获取日志类型
+      * @param functionName 函数名
+      * @return 日志类型
+      */
+     LogType getLogType(const std::string& functionName) const;
+ 
+     /**
+      * @brief 提取日志消息
+      * @param callExpr 函数调用表达式
+      * @return 日志消息
+      */
+     std::string extractLogMessage(const ast_analyzer::ASTNodeInfo* callExpr) const;
+ 
+     const config::Config& config_;  ///< 配置
+     const ast_analyzer::ASTAnalyzer& astAnalyzer_;  ///< AST分析器
+ 
+     std::unordered_set<std::string> logFunctionNames_;  ///< 日志函数名集合
+     std::unordered_map<std::string, LogLevel> functionNameToLevel_;  ///< 函数名到日志级别的映射
+     std::unordered_map<std::string, LogType> functionNameToType_;  ///< 函数名到日志类型的映射
+     std::unordered_map<std::string, std::vector<LogCallInfo>> logCalls_;  ///< 日志调用信息映射表
+ };
+ 
+ } // namespace log_identifier
+ } // namespace core
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_CORE_LOG_IDENTIFIER_LOG_IDENTIFIER_H 
```

---

现在创建覆盖率计算器模块的头文件：

---

```diff
- 
+ /**
+  * @file coverage_calculator.h
+  * @brief 覆盖率计算器定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_CORE_COVERAGE_COVERAGE_CALCULATOR_H
+ #define DLOGCOVER_CORE_COVERAGE_COVERAGE_CALCULATOR_H
+ 
+ #include <string>
+ #include <vector>
+ #include <unordered_map>
+ #include <dlogcover/config/config.h>
+ #include <dlogcover/core/ast_analyzer/ast_analyzer.h>
+ #include <dlogcover/core/log_identifier/log_identifier.h>
+ 
+ namespace dlogcover {
+ namespace core {
+ namespace coverage {
+ 
+ /**
+  * @brief 覆盖率类型枚举
+  */
+ enum class CoverageType {
+     FUNCTION,   ///< 函数级
+     BRANCH,     ///< 分支级
+     EXCEPTION,  ///< 异常级
+     KEY_PATH    ///< 关键路径
+ };
+ 
+ /**
+  * @brief 未覆盖路径信息结构体
+  */
+ struct UncoveredPathInfo {
+     CoverageType type;                      ///< 覆盖率类型
+     ast_analyzer::NodeType nodeType;        ///< 节点类型
+     ast_analyzer::Location location;        ///< 位置信息
+     std::string name;                       ///< 名称
+     std::string text;                       ///< 文本
+     std::string suggestion;                 ///< 建议
+ };
+ 
+ /**
+  * @brief 覆盖率统计信息结构体
+  */
+ struct CoverageStats {
+     double functionCoverage = 0.0;          ///< 函数级覆盖率
+     double branchCoverage = 0.0;            ///< 分支级覆盖率
+     double exceptionCoverage = 0.0;         ///< 异常级覆盖率
+     double keyPathCoverage = 0.0;           ///< 关键路径覆盖率
+     double overallCoverage = 0.0;           ///< 总体覆盖率
+ 
+     int totalFunctions = 0;                 ///< 函数总数
+     int totalBranches = 0;                  ///< 分支总数
+     int totalExceptionHandlers = 0;         ///< 异常处理总数
+     int totalKeyPaths = 0;                  ///< 关键路径总数
+ 
+     int coveredFunctions = 0;               ///< 覆盖的函数数
+     int coveredBranches = 0;                ///< 覆盖的分支数
+     int coveredExceptionHandlers = 0;       ///< 覆盖的异常处理数
+     int coveredKeyPaths = 0;                ///< 覆盖的关键路径数
+ 
+     std::vector<UncoveredPathInfo> uncoveredPaths;  ///< 未覆盖路径列表
+ };
+ 
+ /**
+  * @brief 覆盖率计算器类
+  */
+ class CoverageCalculator {
+ public:
+     /**
+      * @brief 构造函数
+      * @param config 配置
+      * @param astAnalyzer AST分析器
+      * @param logIdentifier 日志识别器
+      */
+     CoverageCalculator(const config::Config& config,
+                        const ast_analyzer::ASTAnalyzer& astAnalyzer,
+                        const log_identifier::LogIdentifier& logIdentifier);
+ 
+     /**
+      * @brief 析构函数
+      */
+     ~CoverageCalculator();
+ 
+     /**
+      * @brief 计算覆盖率
+      * @return 计算成功返回true，否则返回false
+      */
+     bool calculate();
+ 
+     /**
+      * @brief 获取覆盖率统计信息
+      * @param filePath 文件路径
+      * @return 覆盖率统计信息
+      */
+     const CoverageStats& getCoverageStats(const std::string& filePath) const;
+ 
+     /**
+      * @brief 获取总体覆盖率统计信息
+      * @return 总体覆盖率统计信息
+      */
+     const CoverageStats& getOverallCoverageStats() const;
+ 
+     /**
+      * @brief 获取所有覆盖率统计信息
+      * @return 覆盖率统计信息映射表
+      */
+     const std::unordered_map<std::string, CoverageStats>& 
+     getAllCoverageStats() const;
+ 
+ private:
+     /**
+      * @brief 计算函数级覆盖率
+      * @param node AST节点信息
+      * @param filePath 文件路径
+      * @param stats 覆盖率统计信息
+      */
+     void calculateFunctionCoverage(const ast_analyzer::ASTNodeInfo* node,
+                                   const std::string& filePath,
+                                   CoverageStats& stats);
+ 
+     /**
+      * @brief 计算分支级覆盖率
+      * @param node AST节点信息
+      * @param filePath 文件路径
+      * @param stats 覆盖率统计信息
+      */
+     void calculateBranchCoverage(const ast_analyzer::ASTNodeInfo* node,
+                                 const std::string& filePath,
+                                 CoverageStats& stats);
+ 
+     /**
+      * @brief 计算异常级覆盖率
+      * @param node AST节点信息
+      * @param filePath 文件路径
+      * @param stats 覆盖率统计信息
+      */
+     void calculateExceptionCoverage(const ast_analyzer::ASTNodeInfo* node,
+                                    const std::string& filePath,
+                                    CoverageStats& stats);
+ 
+     /**
+      * @brief 计算关键路径覆盖率
+      * @param node AST节点信息
+      * @param filePath 文件路径
+      * @param stats 覆盖率统计信息
+      */
+     void calculateKeyPathCoverage(const ast_analyzer::ASTNodeInfo* node,
+                                  const std::string& filePath,
+                                  CoverageStats& stats);
+ 
+     /**
+      * @brief 合并覆盖率统计信息
+      * @param stats 覆盖率统计信息
+      */
+     void mergeCoverageStats(CoverageStats& overall);
+ 
+     /**
+      * @brief 生成覆盖率建议
+      * @param type 覆盖率类型
+      * @param nodeType 节点类型
+      * @return 建议
+      */
+     std::string generateSuggestion(CoverageType type,
+                                   ast_analyzer::NodeType nodeType) const;
+ 
+     const config::Config& config_;  ///< 配置
+     const ast_analyzer::ASTAnalyzer& astAnalyzer_;  ///< AST分析器
+     const log_identifier::LogIdentifier& logIdentifier_;  ///< 日志识别器
+ 
+     std::unordered_map<std::string, CoverageStats> coverageStats_;  ///< 覆盖率统计信息映射表
+     CoverageStats overallStats_;  ///< 总体覆盖率统计信息
+ };
+ 
+ } // namespace coverage
+ } // namespace core
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_CORE_COVERAGE_COVERAGE_CALCULATOR_H 
```

---

创建报告生成器模块的头文件：

---

```diff
- 
+ /**
+  * @file reporter.h
+  * @brief 报告生成器定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_REPORTER_REPORTER_H
+ #define DLOGCOVER_REPORTER_REPORTER_H
+ 
+ #include <string>
+ #include <dlogcover/config/config.h>
+ #include <dlogcover/core/coverage/coverage_calculator.h>
+ 
+ namespace dlogcover {
+ namespace reporter {
+ 
+ /**
+  * @brief 报告生成器类
+  */
+ class Reporter {
+ public:
+     /**
+      * @brief 构造函数
+      * @param config 配置
+      * @param coverageCalculator 覆盖率计算器
+      */
+     Reporter(const config::Config& config,
+              const core::coverage::CoverageCalculator& coverageCalculator);
+ 
+     /**
+      * @brief 析构函数
+      */
+     ~Reporter();
+ 
+     /**
+      * @brief 生成报告
+      * @param outputPath 输出路径
+      * @return 生成成功返回true，否则返回false
+      */
+     bool generateReport(const std::string& outputPath);
+ 
+ private:
+     /**
+      * @brief 生成文本格式报告
+      * @param outputPath 输出路径
+      * @return 生成成功返回true，否则返回false
+      */
+     bool generateTextReport(const std::string& outputPath);
+ 
+     /**
+      * @brief 生成JSON格式报告
+      * @param outputPath 输出路径
+      * @return 生成成功返回true，否则返回false
+      */
+     bool generateJsonReport(const std::string& outputPath);
+ 
+     /**
+      * @brief 生成总体统计信息
+      * @param stats 覆盖率统计信息
+      * @return 总体统计信息
+      */
+     std::string generateOverallStatsText(
+         const core::coverage::CoverageStats& stats) const;
+ 
+     /**
+      * @brief 生成文件统计信息
+      * @param filePath 文件路径
+      * @param stats 覆盖率统计信息
+      * @return 文件统计信息
+      */
+     std::string generateFileStatsText(
+         const std::string& filePath,
+         const core::coverage::CoverageStats& stats) const;
+ 
+     /**
+      * @brief 生成未覆盖路径信息
+      * @param uncoveredPath 未覆盖路径信息
+      * @return 未覆盖路径信息
+      */
+     std::string generateUncoveredPathText(
+         const core::coverage::UncoveredPathInfo& uncoveredPath) const;
+ 
+     /**
+      * @brief 生成建议信息
+      * @param stats 覆盖率统计信息
+      * @return 建议信息
+      */
+     std::string generateSuggestionsText(
+         const core::coverage::CoverageStats& stats) const;
+ 
+     /**
+      * @brief 生成当前日期时间字符串
+      * @return 日期时间字符串
+      */
+     std::string getCurrentDateTimeString() const;
+ 
+     const config::Config& config_;  ///< 配置
+     const core::coverage::CoverageCalculator& coverageCalculator_;  ///< 覆盖率计算器
+ };
+ 
+ } // namespace reporter
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_REPORTER_REPORTER_H 
```

---

创建工具函数相关的头文件：

---

```diff
- 
+ /**
+  * @file file_utils.h
+  * @brief 文件工具函数定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_UTILS_FILE_UTILS_H
+ #define DLOGCOVER_UTILS_FILE_UTILS_H
+ 
+ #include <string>
+ #include <vector>
+ #include <functional>
+ 
+ namespace dlogcover {
+ namespace utils {
+ 
+ /**
+  * @brief 判断文件是否存在
+  * @param path 文件路径
+  * @return 存在返回true，否则返回false
+  */
+ bool fileExists(const std::string& path);
+ 
+ /**
+  * @brief 判断目录是否存在
+  * @param path 目录路径
+  * @return 存在返回true，否则返回false
+  */
+ bool directoryExists(const std::string& path);
+ 
+ /**
+  * @brief 创建目录
+  * @param path 目录路径
+  * @return 创建成功返回true，否则返回false
+  */
+ bool createDirectory(const std::string& path);
+ 
+ /**
+  * @brief 读取文件内容
+  * @param path 文件路径
+  * @param content 输出内容
+  * @return 读取成功返回true，否则返回false
+  */
+ bool readFile(const std::string& path, std::string& content);
+ 
+ /**
+  * @brief 写入文件内容
+  * @param path 文件路径
+  * @param content 文件内容
+  * @return 写入成功返回true，否则返回false
+  */
+ bool writeFile(const std::string& path, const std::string& content);
+ 
+ /**
+  * @brief 获取文件大小
+  * @param path 文件路径
+  * @return 文件大小
+  */
+ size_t getFileSize(const std::string& path);
+ 
+ /**
+  * @brief 获取文件扩展名
+  * @param path 文件路径
+  * @return 文件扩展名
+  */
+ std::string getFileExtension(const std::string& path);
+ 
+ /**
+  * @brief 获取文件名(不含路径和扩展名)
+  * @param path 文件路径
+  * @return 文件名
+  */
+ std::string getFileName(const std::string& path);
+ 
+ /**
+  * @brief 获取目录名
+  * @param path 文件路径
+  * @return 目录名
+  */
+ std::string getDirectoryName(const std::string& path);
+ 
+ /**
+  * @brief 列出目录下所有文件
+  * @param path 目录路径
+  * @param pattern 文件模式
+  * @param recursive 是否递归查找
+  * @return 文件列表
+  */
+ std::vector<std::string> listFiles(const std::string& path, 
+                                   const std::string& pattern = "", 
+                                   bool recursive = false);
+ 
+ /**
+  * @brief 列出目录下所有文件
+  * @param path 目录路径
+  * @param callback 回调函数
+  * @param pattern 文件模式
+  * @param recursive 是否递归查找
+  * @return 成功返回true，否则返回false
+  */
+ bool listFiles(const std::string& path, 
+               const std::function<bool(const std::string&)>& callback,
+               const std::string& pattern = "", 
+               bool recursive = false);
+ 
+ /**
+  * @brief 结合路径
+  * @param path1 路径1
+  * @param path2 路径2
+  * @return 结合后的路径
+  */
+ std::string combinePath(const std::string& path1, const std::string& path2);
+ 
+ /**
+  * @brief 获取规范化路径
+  * @param path 路径
+  * @return 规范化路径
+  */
+ std::string normalizePath(const std::string& path);
+ 
+ /**
+  * @brief 获取相对路径
+  * @param path 路径
+  * @param basePath 基础路径
+  * @return 相对路径
+  */
+ std::string getRelativePath(const std::string& path, const std::string& basePath);
+ 
+ } // namespace utils
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_UTILS_FILE_UTILS_H 
```

---

```diff
- 
+ /**
+  * @file string_utils.h
+  * @brief 字符串工具函数定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_UTILS_STRING_UTILS_H
+ #define DLOGCOVER_UTILS_STRING_UTILS_H
+ 
+ #include <string>
+ #include <vector>
+ 
+ namespace dlogcover {
+ namespace utils {
+ 
+ /**
+  * @brief 字符串分割
+  * @param str 待分割字符串
+  * @param delim 分隔符
+  * @return 分割后的字符串列表
+  */
+ std::vector<std::string> split(const std::string& str, const std::string& delim);
+ 
+ /**
+  * @brief 字符串连接
+  * @param vec 字符串列表
+  * @param delim 分隔符
+  * @return 连接后的字符串
+  */
+ std::string join(const std::vector<std::string>& vec, const std::string& delim);
+ 
+ /**
+  * @brief 字符串替换
+  * @param str 原字符串
+  * @param from 待替换的子串
+  * @param to 替换为的子串
+  * @return 替换后的字符串
+  */
+ std::string replace(const std::string& str, const std::string& from, const std::string& to);
+ 
+ /**
+  * @brief 检查字符串是否以指定前缀开始
+  * @param str 字符串
+  * @param prefix 前缀
+  * @return 以prefix开始则返回true，否则返回false
+  */
+ bool startsWith(const std::string& str, const std::string& prefix);
+ 
+ /**
+  * @brief 检查字符串是否以指定后缀结束
+  * @param str 字符串
+  * @param suffix 后缀
+  * @return 以suffix结束则返回true，否则返回false
+  */
+ bool endsWith(const std::string& str, const std::string& suffix);
+ 
+ /**
+  * @brief 转换为小写
+  * @param str 原字符串
+  * @return 转换后的字符串
+  */
+ std::string toLower(const std::string& str);
+ 
+ /**
+  * @brief 转换为大写
+  * @param str 原字符串
+  * @return 转换后的字符串
+  */
+ std::string toUpper(const std::string& str);
+ 
+ /**
+  * @brief 去除字符串前后的空白
+  * @param str 原字符串
+  * @return 去除空白后的字符串
+  */
+ std::string trim(const std::string& str);
+ 
+ /**
+  * @brief 去除字符串前面的空白
+  * @param str 原字符串
+  * @return 去除前面空白后的字符串
+  */
+ std::string trimLeft(const std::string& str);
+ 
+ /**
+  * @brief 去除字符串后面的空白
+  * @param str 原字符串
+  * @return 去除后面空白后的字符串
+  */
+ std::string trimRight(const std::string& str);
+ 
+ /**
+  * @brief 格式化字符串
+  * @param format 格式字符串
+  * @param ... 参数
+  * @return 格式化后的字符串
+  */
+ std::string format(const char* format, ...);
+ 
+ /**
+  * @brief 尝试将字符串转换为整数
+  * @param str 字符串
+  * @param value 转换结果
+  * @return 转换成功返回true，否则返回false
+  */
+ bool tryParseInt(const std::string& str, int& value);
+ 
+ /**
+  * @brief 尝试将字符串转换为浮点数
+  * @param str 字符串
+  * @param value 转换结果
+  * @return 转换成功返回true，否则返回false
+  */
+ bool tryParseDouble(const std::string& str, double& value);
+ 
+ /**
+  * @brief 生成重复字符串
+  * @param str 待重复的字符串
+  * @param count 重复次数
+  * @return 重复后的字符串
+  */
+ std::string repeat(const std::string& str, int count);
+ 
+ } // namespace utils
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_UTILS_STRING_UTILS_H 
```

---

```diff
- 
+ /**
+  * @file log_utils.h
+  * @brief 日志工具函数定义
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #ifndef DLOGCOVER_UTILS_LOG_UTILS_H
+ #define DLOGCOVER_UTILS_LOG_UTILS_H
+ 
+ #include <string>
+ 
+ namespace dlogcover {
+ namespace utils {
+ 
+ /**
+  * @brief 日志级别枚举
+  */
+ enum class LogLevel {
+     DEBUG,    ///< 调试级别
+     INFO,     ///< 信息级别
+     WARNING,  ///< 警告级别
+     ERROR,    ///< 错误级别
+     FATAL     ///< 致命级别
+ };
+ 
+ /**
+  * @brief 日志实用工具类
+  */
+ class Logger {
+ public:
+     /**
+      * @brief 初始化日志系统
+      * @param logFileName 日志文件名
+      * @param consoleOutput 是否输出到控制台
+      * @param level 日志级别
+      * @return 初始化成功返回true，否则返回false
+      */
+     static bool init(const std::string& logFileName, 
+                     bool consoleOutput = true, 
+                     LogLevel level = LogLevel::INFO);
+ 
+     /**
+      * @brief 关闭日志系统
+      */
+     static void shutdown();
+ 
+     /**
+      * @brief 设置日志级别
+      * @param level 日志级别
+      */
+     static void setLogLevel(LogLevel level);
+ 
+     /**
+      * @brief 获取日志级别
+      * @return 日志级别
+      */
+     static LogLevel getLogLevel();
+ 
+     /**
+      * @brief 调试日志
+      * @param message 日志消息
+      */
+     static void debug(const std::string& message);
+ 
+     /**
+      * @brief 信息日志
+      * @param message 日志消息
+      */
+     static void info(const std::string& message);
+ 
+     /**
+      * @brief 警告日志
+      * @param message 日志消息
+      */
+     static void warning(const std::string& message);
+ 
+     /**
+      * @brief 错误日志
+      * @param message 日志消息
+      */
+     static void error(const std::string& message);
+ 
+     /**
+      * @brief 致命日志
+      * @param message 日志消息
+      */
+     static void fatal(const std::string& message);
+ 
+     /**
+      * @brief 格式化日志
+      * @param level 日志级别
+      * @param format 格式
+      * @param ... 参数
+      */
+     static void log(LogLevel level, const char* format, ...);
+ 
+ private:
+     /**
+      * @brief 日志输出
+      * @param level 日志级别
+      * @param message 日志消息
+      */
+     static void logOutput(LogLevel level, const std::string& message);
+ 
+     /**
+      * @brief 获取级别名称
+      * @param level 日志级别
+      * @return 级别名称
+      */
+     static std::string getLevelName(LogLevel level);
+ 
+     /**
+      * @brief 获取当前时间字符串
+      * @return 当前时间字符串
+      */
+     static std::string getCurrentTimeString();
+ };
+ 
+ // 日志宏定义
+ #define LOG_DEBUG(message) dlogcover::utils::Logger::debug(message)
+ #define LOG_INFO(message) dlogcover::utils::Logger::info(message)
+ #define LOG_WARNING(message) dlogcover::utils::Logger::warning(message)
+ #define LOG_ERROR(message) dlogcover::utils::Logger::error(message)
+ #define LOG_FATAL(message) dlogcover::utils::Logger::fatal(message)
+ 
+ #define LOG_DEBUG_FMT(...) dlogcover::utils::Logger::log(dlogcover::utils::LogLevel::DEBUG, __VA_ARGS__)
+ #define LOG_INFO_FMT(...) dlogcover::utils::Logger::log(dlogcover::utils::LogLevel::INFO, __VA_ARGS__)
+ #define LOG_WARNING_FMT(...) dlogcover::utils::Logger::log(dlogcover::utils::LogLevel::WARNING, __VA_ARGS__)
+ #define LOG_ERROR_FMT(...) dlogcover::utils::Logger::log(dlogcover::utils::LogLevel::ERROR, __VA_ARGS__)
+ #define LOG_FATAL_FMT(...) dlogcover::utils::Logger::log(dlogcover::utils::LogLevel::FATAL, __VA_ARGS__)
+ 
+ } // namespace utils
+ } // namespace dlogcover
+ 
+ #endif // DLOGCOVER_UTILS_LOG_UTILS_H 
```

---

最后，创建主程序入口文件：

---

```diff
- 
+ /**
+  * @file main.cpp
+  * @brief 程序入口
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #include <iostream>
+ #include <string>
+ #include <chrono>
+ #include <filesystem>
+ #include <dlogcover/cli/command_line_parser.h>
+ #include <dlogcover/config/config_manager.h>
+ #include <dlogcover/source_manager/source_manager.h>
+ #include <dlogcover/core/ast_analyzer/ast_analyzer.h>
+ #include <dlogcover/core/log_identifier/log_identifier.h>
+ #include <dlogcover/core/coverage/coverage_calculator.h>
+ #include <dlogcover/reporter/reporter.h>
+ #include <dlogcover/utils/log_utils.h>
+ 
+ using namespace dlogcover;
+ 
+ int main(int argc, char* argv[]) {
+     try {
+         // 初始化日志系统
+         std::string logFileName = "dlogcover.log";
+         utils::Logger::init(logFileName, true, utils::LogLevel::INFO);
+         LOG_INFO("DLogCover启动");
+ 
+         // 解析命令行参数
+         cli::CommandLineParser commandLineParser;
+         if (!commandLineParser.parse(argc, argv)) {
+             return 1;
+         }
+ 
+         // 获取命令行选项
+         const cli::Options& options = commandLineParser.getOptions();
+ 
+         // 加载配置文件
+         config::ConfigManager configManager;
+         if (!configManager.loadConfig(options.configPath)) {
+             LOG_ERROR("无法加载配置文件: " + options.configPath);
+             return 1;
+         }
+ 
+         // 与命令行选项合并
+         configManager.mergeWithCommandLineOptions(options);
+ 
+         // 验证配置
+         if (!configManager.validateConfig()) {
+             LOG_ERROR("配置验证失败");
+             return 1;
+         }
+ 
+         const config::Config& config = configManager.getConfig();
+ 
+         // 创建源文件管理器
+         LOG_INFO("开始收集源文件");
+         source_manager::SourceManager sourceManager(config);
+         if (!sourceManager.collectSourceFiles()) {
+             LOG_ERROR("源文件收集失败");
+             return 1;
+         }
+         LOG_INFO_FMT("共收集到%lu个源文件", sourceManager.getSourceFileCount());
+ 
+         // 创建AST分析器
+         LOG_INFO("开始AST分析");
+         core::ast_analyzer::ASTAnalyzer astAnalyzer(config, sourceManager);
+         if (!astAnalyzer.analyzeAll()) {
+             LOG_ERROR("AST分析失败");
+             return 1;
+         }
+         LOG_INFO("AST分析完成");
+ 
+         // 创建日志识别器
+         LOG_INFO("开始识别日志调用");
+         core::log_identifier::LogIdentifier logIdentifier(config, astAnalyzer);
+         if (!logIdentifier.identifyLogCalls()) {
+             LOG_ERROR("日志调用识别失败");
+             return 1;
+         }
+         LOG_INFO("日志调用识别完成");
+ 
+         // 创建覆盖率计算器
+         LOG_INFO("开始计算覆盖率");
+         core::coverage::CoverageCalculator coverageCalculator(config, astAnalyzer, logIdentifier);
+         if (!coverageCalculator.calculate()) {
+             LOG_ERROR("覆盖率计算失败");
+             return 1;
+         }
+         LOG_INFO("覆盖率计算完成");
+ 
+         // 生成报告
+         LOG_INFO("开始生成报告");
+         reporter::Reporter reporter(config, coverageCalculator);
+         if (!reporter.generateReport(options.outputPath)) {
+             LOG_ERROR("报告生成失败");
+             return 1;
+         }
+         LOG_INFO("报告生成完成: " + options.outputPath);
+ 
+         LOG_INFO("DLogCover执行完成");
+         utils::Logger::shutdown();
+         return 0;
+     } catch (const std::exception& e) {
+         std::cerr << "错误: " << e.what() << std::endl;
+         LOG_ERROR(std::string("异常: ") + e.what());
+         utils::Logger::shutdown();
+         return 1;
+     } catch (...) {
+         std::cerr << "未知错误" << std::endl;
+         LOG_ERROR("未知异常");
+         utils::Logger::shutdown();
+         return 1;
+     }
+ } 
```

---

创建示例配置文件：

---

```bash
mkdir -p examples
```

```
ut000520@wangbo:/data/workspace/git/dlogcover|main⚡ ⇒  

```

---

```diff
- 
+ {
+   "scan": {
+     "directories": ["./"],
+     "excludes": ["build/", "test/", "third_party/"],
+     "file_types": [".cpp", ".cc", ".cxx", ".h", ".hpp"]
+   },
+   "log_functions": {
+     "qt": {
+       "enabled": true,
+       "functions": ["qDebug", "qInfo", "qWarning", "qCritical", "qFatal"],
+       "category_functions": ["qCDebug", "qCInfo", "qCWarning", "qCCritical"]
+     },
+     "custom": {
+       "enabled": true,
+       "functions": {
+         "debug": ["fmDebug", "LOG_DEBUG", "LOG_DEBUG_FMT"],
+         "info": ["fmInfo", "LOG_INFO", "LOG_INFO_FMT"],
+         "warning": ["fmWarning", "LOG_WARNING", "LOG_WARNING_FMT"],
+         "critical": ["fmCritical", "LOG_ERROR", "LOG_ERROR_FMT", "LOG_FATAL", "LOG_FATAL_FMT"]
+       }
+     }
+   },
+   "analysis": {
+     "function_coverage": true,
+     "branch_coverage": true,
+     "exception_coverage": true,
+     "key_path_coverage": true
+   },
+   "report": {
+     "format": "text",
+     "timestamp_format": "YYYYMMDD_HHMMSS"
+   }
+ } 
```

---

更新README.md以反映项目的实现内容：

---

```diff
  - 生成日志覆盖率报告
  - 提供改进建议
+ 
+ ## 项目架构
+ DLogCover系统的整体结构采用分层架构，主要分为以下几个层次：
+ 
+ 1. **命令行接口层**：负责处理用户输入的命令行参数，提供友好的交互界面。
+ 2. **配置管理层**：负责读取和管理配置文件，处理扫描路径、排除规则等配置。
+ 3. **源文件管理层**：负责收集需要分析的源文件，处理文件过滤和路径解析。
+ 4. **AST分析层**：基于Clang/LLVM工具链，对C++源代码进行抽象语法树分析。
+ 5. **日志识别层**：识别代码中的日志函数调用，包括Qt日志函数和自定义日志函数。
+ 6. **覆盖率计算层**：计算各种覆盖率指标，如函数级覆盖率、分支覆盖率等。
+ 7. **报告生成层**：将分析结果整理成易于理解的报告，提供总体覆盖率和未覆盖路径列表等信息。
+ 
+ ## 技术栈
+ - 开发语言：Modern C++ (C++17)
+ - 静态分析：Clang/LLVM LibTooling
+ - 配置文件格式：JSON
+ - 命令行解析：Boost Program Options
+ - 文件操作：C++17 std::filesystem
+ - 单元测试：GoogleTest
+ 
+ ## 构建与安装
+ 
+ ### 依赖项
+ - CMake 3.10+
+ - GCC 7+ 或 Clang 5+（支持C++17）
+ - LLVM/Clang 开发库
+ - Boost 库（Program Options组件）
+ 
+ ### 构建步骤
+ ```bash
+ # 克隆仓库
+ git clone https://github.com/yourusername/dlogcover.git
+ cd dlogcover
+ 
+ # 创建构建目录
+ mkdir build && cd build
+ 
+ # 配置
+ cmake ..
+ 
+ # 构建
+ make
+ 
+ # 安装
+ sudo make install
+ ```
+ 
+ ## 使用说明
+ 
+ ### 命令行参数
+ ```
+ dlogcover [选项]
+ 
+ 选项:
+   -h, --help                 显示帮助信息
+   -d, --directory <path>     指定扫描目录 (默认: ./)
+   -o, --output <path>        指定输出报告路径 (默认: ./dlogcover_report_<timestamp>.txt)
+   -c, --config <path>        指定配置文件路径 (默认: ./dlogcover.json)
+   -e, --exclude <pattern>    排除符合模式的文件或目录 (可多次使用)
+   -l, --log-level <level>    指定最低日志级别进行过滤
+   -f, --format <format>      指定报告格式 (text, json)
+ ```
+ 
+ ### 示例用法
+ ```bash
+ # 使用默认配置分析当前目录
+ dlogcover
+ 
+ # 指定目录和输出路径
+ dlogcover -d /path/to/source -o /path/to/output.txt
+ 
+ # 使用自定义配置文件
+ dlogcover -c /path/to/config.json
+ 
+ # 排除特定目录
+ dlogcover -e "build/*" -e "test/*"
+ ```
+ 
+ ### 配置文件
+ 配置文件采用JSON格式，示例如下：
+ ```json
+ {
+   "scan": {
+     "directories": ["./"],
+     "excludes": ["build/", "test/"],
+     "file_types": [".cpp", ".cc", ".cxx", ".h", ".hpp"]
+   },
+   "log_functions": {
+     "qt": {
+       "enabled": true,
+       "functions": ["qDebug", "qInfo", "qWarning", "qCritical", "qFatal"],
+       "category_functions": ["qCDebug", "qCInfo", "qCWarning", "qCCritical"]
+     },
+     "custom": {
+       "enabled": true,
+       "functions": {
+         "debug": ["fmDebug"],
+         "info": ["fmInfo"],
+         "warning": ["fmWarning"],
+         "critical": ["fmCritical"]
+       }
+     }
+   },
+   "analysis": {
+     "function_coverage": true,
+     "branch_coverage": true,
+     "exception_coverage": true,
+     "key_path_coverage": true
+   },
+   "report": {
+     "format": "text",
+     "timestamp_format": "YYYYMMDD_HHMMSS"
+   }
+ }
+ ```
+ 
+ ## 实现状态
+ - [x] 项目结构搭建
+ - [x] 命令行接口设计
+ - [x] 配置管理模块设计
+ - [x] 源文件管理模块设计
+ - [x] AST分析模块设计
+ - [x] 日志识别模块设计
+ - [x] 覆盖率计算模块设计
+ - [x] 报告生成模块设计
+ - [ ] 命令行接口实现
+ - [ ] 配置管理模块实现
+ - [ ] 源文件管理模块实现
+ - [ ] AST分析模块实现
+ - [ ] 日志识别模块实现
+ - [ ] 覆盖率计算模块实现
+ - [ ] 报告生成模块实现
+ - [ ] 单元测试
+ - [ ] 集成测试
+ - [ ] 文档完善
  
  ## 项目文档
```

```diff
  - [详细设计文档](docs/详细设计文档.md) - 描述系统详细设计和实现方案，包含实现计划、测试策略、部署说明等完整内容
  
- ## 安装与使用
- 待完善
+ ## 贡献指南
+ 欢迎提交问题报告和功能请求。如果您想贡献代码，请先fork本仓库，然后创建一个新的分支，提交您的更改，并发送pull请求。
  
  ## 许可证
```

---

## 最终总结

我已经根据架构设计文档完成了DLogCover项目的基本框架搭建。以下是已完成的工作：

1. 创建了完整的项目目录结构：
   - src/: 源代码目录
   - include/dlogcover/: 头文件目录
   - examples/: 示例配置文件
   - 根据分层架构划分了子目录

2. 创建了各个模块的头文件：
   - 命令行接口层：command_line_parser.h, options.h
   - 配置管理层：config_manager.h, config.h
   - 源文件管理层：source_manager.h
   - AST分析层：ast_analyzer.h
   - 日志识别层：log_identifier.h
   - 覆盖率计算层：coverage_calculator.h
   - 报告生成层：reporter.h
   - 工具函数：file_utils.h, string_utils.h, log_utils.h

3. 创建了主程序入口 main.cpp

4. 创建了CMakeLists.txt构建配置文件

5. 创建了示例配置文件

6. 更新了README.md，添加了详细的项目信息和使用说明

该项目现在处于设计阶段，头文件已经定义了所有必要的接口和数据结构。接下来需要实现这些接口的源代码（.cpp文件），然后进行单元测试和集成测试。

产品需求文档中的功能需求已经在设计阶段覆盖：
- [x] 命令行支持（参数、启动方式、配置等）
- [x] 代码分析能力（静态扫描、日志识别）
- [x] 覆盖率分析功能（基础分析、日志级别分析）
- [x] 报告生成功能（文本报告、配置文件）

非功能需求（性能要求和可用性要求）也已在设计中考虑。

接下来需要完成的工作：
1. 实现各个模块的源代码文件
2. 添加单元测试和集成测试
3. 进行性能优化
4. 完善文档和示例

---

_**User**_

继续

---

_**Assistant**_



---

# Mode: ACT

我将继续实现DLogCover项目的源代码文件。按照依赖关系，我会从底层工具类开始，然后逐步向上实现各个模块。

首先，让我实现utils目录下的工具类：

---

```diff
- 
+ /**
+  * @file file_utils.cpp
+  * @brief 文件工具函数实现
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #include <dlogcover/utils/file_utils.h>
+ #include <filesystem>
+ #include <fstream>
+ #include <sstream>
+ #include <algorithm>
+ #include <regex>
+ 
+ namespace fs = std::filesystem;
+ 
+ namespace dlogcover {
+ namespace utils {
+ 
+ bool fileExists(const std::string& path) {
+     return fs::exists(path) && fs::is_regular_file(path);
+ }
+ 
+ bool directoryExists(const std::string& path) {
+     return fs::exists(path) && fs::is_directory(path);
+ }
+ 
+ bool createDirectory(const std::string& path) {
+     try {
+         return fs::create_directories(path);
+     } catch (const std::exception&) {
+         return false;
+     }
+ }
+ 
+ bool readFile(const std::string& path, std::string& content) {
+     try {
+         if (!fileExists(path)) {
+             return false;
+         }
+         
+         std::ifstream file(path, std::ios::in | std::ios::binary);
+         if (!file.is_open()) {
+             return false;
+         }
+         
+         std::stringstream buffer;
+         buffer << file.rdbuf();
+         content = buffer.str();
+         
+         file.close();
+         return true;
+     } catch (const std::exception&) {
+         return false;
+     }
+ }
+ 
+ bool writeFile(const std::string& path, const std::string& content) {
+     try {
+         std::ofstream file(path, std::ios::out | std::ios::binary);
+         if (!file.is_open()) {
+             return false;
+         }
+         
+         file << content;
+         file.close();
+         return true;
+     } catch (const std::exception&) {
+         return false;
+     }
+ }
+ 
+ size_t getFileSize(const std::string& path) {
+     try {
+         if (!fileExists(path)) {
+             return 0;
+         }
+         
+         return static_cast<size_t>(fs::file_size(path));
+     } catch (const std::exception&) {
+         return 0;
+     }
+ }
+ 
+ std::string getFileExtension(const std::string& path) {
+     return fs::path(path).extension().string();
+ }
+ 
+ std::string getFileName(const std::string& path) {
+     return fs::path(path).stem().string();
+ }
+ 
+ std::string getDirectoryName(const std::string& path) {
+     return fs::path(path).parent_path().string();
+ }
+ 
+ std::vector<std::string> listFiles(const std::string& path, 
+                                   const std::string& pattern, 
+                                   bool recursive) {
+     std::vector<std::string> files;
+     
+     try {
+         if (!directoryExists(path)) {
+             return files;
+         }
+         
+         std::regex patternRegex;
+         bool hasPattern = !pattern.empty();
+         if (hasPattern) {
+             try {
+                 patternRegex = std::regex(pattern, std::regex::ECMAScript);
+             } catch (const std::regex_error&) {
+                 hasPattern = false;
+             }
+         }
+         
+         auto iterator = recursive 
+             ? fs::recursive_directory_iterator(path) 
+             : fs::directory_iterator(path);
+         
+         for (const auto& entry : iterator) {
+             if (entry.is_regular_file()) {
+                 std::string filePath = entry.path().string();
+                 if (!hasPattern || std::regex_match(filePath, patternRegex)) {
+                     files.push_back(filePath);
+                 }
+             }
+         }
+     } catch (const std::exception&) {
+         // 忽略异常
+     }
+     
+     return files;
+ }
+ 
+ bool listFiles(const std::string& path, 
+               const std::function<bool(const std::string&)>& callback,
+               const std::string& pattern, 
+               bool recursive) {
+     try {
+         if (!directoryExists(path)) {
+             return false;
+         }
+         
+         std::regex patternRegex;
+         bool hasPattern = !pattern.empty();
+         if (hasPattern) {
+             try {
+                 patternRegex = std::regex(pattern, std::regex::ECMAScript);
+             } catch (const std::regex_error&) {
+                 hasPattern = false;
+             }
+         }
+         
+         auto iterator = recursive 
+             ? fs::recursive_directory_iterator(path) 
+             : fs::directory_iterator(path);
+         
+         for (const auto& entry : iterator) {
+             if (entry.is_regular_file()) {
+                 std::string filePath = entry.path().string();
+                 if (!hasPattern || std::regex_match(filePath, patternRegex)) {
+                     if (!callback(filePath)) {
+                         return false;  // 回调要求停止
+                     }
+                 }
+             }
+         }
+         
+         return true;
+     } catch (const std::exception&) {
+         return false;
+     }
+ }
+ 
+ std::string combinePath(const std::string& path1, const std::string& path2) {
+     return (fs::path(path1) / fs::path(path2)).string();
+ }
+ 
+ std::string normalizePath(const std::string& path) {
+     return fs::path(path).lexically_normal().string();
+ }
+ 
+ std::string getRelativePath(const std::string& path, const std::string& basePath) {
+     try {
+         return fs::relative(path, basePath).string();
+     } catch (const std::exception&) {
+         return path;
+     }
+ }
+ 
+ } // namespace utils
+ } // namespace dlogcover 
```

---

```diff
- 
+ /**
+  * @file string_utils.cpp
+  * @brief 字符串工具函数实现
+  * @copyright Copyright (c) 2023 DLogCover Team
+  */
+ 
+ #include <dlogcover/utils/string_utils.h>
+ #include <algorithm>
+ #include <sstream>
+ #include <cctype>
+ #include <cstdarg>
+ #include <cstdio>
+ #include <locale>
+ #include <stdexcept>
+ 
+ namespace dlogcover {
+ namespace utils {
+ 
+ std::vector<std::string> split(const std::string& str, const std::string& delim) {
+     std::vector<std::string> tokens;
+     size_t prev = 0, pos = 0;
+     
+     do {
+         pos = str.find(delim, prev);
+         if (pos == std::string::npos) {
+             pos = str.length();
+         }
+         
+         std::string token = str.substr(prev, pos - prev);
+         if (!token.empty()) {
+             tokens.push_back(token);
+         }
+         
+         prev = pos + delim.length();
+     } while (pos < str.length() && prev < str.length());
+     
+     return tokens;
+ }
+ 
+ std::string join(const std::vector<std::string>& vec, const std::string& delim) {
+     std::stringstream ss;
+     
+     for (size_t i = 0; i < vec.size(); ++i) {
+         if (i > 0) {
+             ss << delim;
+         }
+         ss << vec[i];
+     }
+     
+     return ss.str();
+ }
+ 
+ std::string replace(const std::string& str, const std::string& from, const std::string& to) {
+     std::string result = str;
+     size_t start_pos = 0;
+     
+     while ((start_pos = result.find(from, start_pos)) != std::string::npos) {
+         result.replace(start_pos, from.length(), to);
+         start_pos += to.length();
+     }
+     
+     return result;
+ }
+ 
+ bool startsWith(const std::string& str, const std::string& prefix) {
+     return str.size() >= prefix.size() && 
+            str.compare(0, prefix.size(), prefix) == 0;
+ }
+ 
+ bool endsWith(const std::string& str, const std::string& suffix) {
+     return str.size() >= suffix.size() && 
+            str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
+ }
+ 
+ std::string toLower(const std::string& str) {
+     std::string result = str;
+     std::transform(result.begin(), result.end(), result.begin(), 
+                   [](unsigned char c) { return std::tolower(c); });
+     return result;
+ }
+ 
+ std::string toUpper(const std::string& str) {
+     std::string result = str;
+     std::transform(result.begin(), result.end(), result.begin(), 
+                   [](unsigned char c) { return std::toupper(c); });
+     return result;
+ }
+ 
+ std::string trim(const std::string& str) {
+     return trimRight(trimLeft(str));
+ }
+ 
+ std::string trimLeft(const std::string& str) {
+     std::string result = str;
+     result.erase(result.begin(), 
+                 std::find_if(result.begin(), result.end(), 
+                             [](unsigned char ch) { 
+                                 return !std::isspace(ch); 
+                             }));
+     return result;
+ }
+ 
+ std::string trimRight(const std::string& str) {
+     std::string result = str;
+     result.erase(std::find_if(result.rbegin(), result.rend(), 
+                              [](unsigned char ch) { 
+                                  return !std::isspace(ch); 
+                              }).base(), 
+                 result.end());
+     return result;
+ }
+ 
+ std::string format(const char* fmt, ...) {
+     const int initialSize = 256;
+     char buffer[initialSize];
+     va_list args;
+     
+     va_start(args, fmt);
+     int result = vsnprintf(buffer, initialSize, fmt, args);
+     va_end(args);
+     
+     if (result < 0) {
+         return {};
+     }
+     
+     if (result < initialSize) {
+         return std::string(buffer, result);
+     }
+     
+     // 如果初始缓冲区不够大，重新分配并重试
+     std::vector<char> largerBuffer(result + 1);
+     
+     va_start(args, fmt);
+     result = vsnprintf(largerBuffer.data(), largerBuffer.size(), fmt, args);
+     va_end(args);
+     
+     if (result < 0) {
+         return {};
+     }
+     
+     return std::string(largerBuffer.data(), result);
+ }
+ 
+ bool tryParseInt(const std::string& str, int& value) {
+     try {
+         size_t pos = 0;
+         value = std::stoi(str, &pos);
+         return pos == str.length();
+     } catch (const std::exception&) {
+         return false;
+     }
+ }
+ 
+ bool tryParseDouble(const std::string& str, double& value) {
+     try {
+         size_t pos = 0;
+         value = std::stod(str, &pos);
+         return pos == str.length();
+     } catch (const std::exception&) {
+         return false;
+     }
+ }
+ 
+ std::string repeat(const std::string& str, int count) {
+     if (count <= 0) {
+         return {};
+     }
+     
+     std::string result;
+     result.reserve(str.size() * count);
+     
+     for (int i = 0; i < count; ++i) {
+         result += str;
+     }
+     
+     return result;
+ }
+ 
+ } // namespace utils
+ } // namespace dlogcover 
```

---

Cancelled

---

_**User**_

/Generate Cursor Rules 

---

_**Assistant**_



---

I'll create some Cursor Rules for the DLogCover project to help with understanding the codebase structure and patterns.

```
.cursor/rules/project-structure.mdc
---
description: Overview of DLogCover project structure
globs: ["**/*.cpp", "**/*.h"]
alwaysApply: true
---
# DLogCover Project Structure

DLogCover is a C++ tool for analyzing log coverage in C++ projects. The system follows a layered architecture with clear separation of concerns.

## Directory Structure

- `include/dlogcover/` - Header files (.h) organized by module
- `src/` - Implementation files (.cpp) organized by module
- `examples/` - Example configuration files and demos
- `tests/` - Unit and integration tests
- `third_party/` - Third-party dependencies

## Module Organization

The code is organized into the following modules:

1. **CLI Layer** (`cli/`) - Command line interface and parameter parsing
2. **Config Layer** (`config/`) - Configuration management for scan settings
3. **Source Manager Layer** (`source_manager/`) - Source file collection and management
4. **Core Layer** (`core/`) with submodules:
   - `ast_analyzer/` - AST parsing and analysis using Clang/LLVM
   - `log_identifier/` - Log function call identification
   - `coverage/` - Coverage calculation and statistics
5. **Reporter Layer** (`reporter/`) - Report generation in different formats
6. **Utils Layer** (`utils/`) - Utility functions for file, string and logging

## Main Flow

The main processing flow follows this sequence:
1. Parse command line arguments
2. Load & validate configuration
3. Collect source files
4. Analyze AST of each source file
5. Identify log calls
6. Calculate coverage metrics
7. Generate reports

## Naming Conventions

- Class names: `PascalCase` 
- Functions/methods: `camelCase`
- Variables: `camelCase`
- Constants/Enums: `ALL_CAPS` or `kPascalCase`
- Namespaces: `lowercase`

## Code Style

- Use C++17 features where appropriate
- Follow Modern C++ practices
- Error handling: Use error codes rather than exceptions for recoverable errors
```

```
.cursor/rules/module-dependencies.mdc
---
description: Module dependencies and initialization flow
globs: ["src/*.cpp", "src/**/*.cpp"]
alwaysApply: true
---
# Module Dependencies

The DLogCover modules have hierarchical dependencies:

```mermaid
graph TD
    CLI[Command Line Interface] --> Config
    Config[Configuration Management] --> SourceManager
    SourceManager[Source File Management] --> ASTAnalyzer
    ASTAnalyzer[AST Analyzer] --> LogIdentifier
    LogIdentifier[Log Identifier] --> CoverageCalculator
    CoverageCalculator[Coverage Calculator] --> Reporter
    Utils[Utility Functions] --> CLI
    Utils --> Config
    Utils --> SourceManager
    Utils --> ASTAnalyzer
    Utils --> LogIdentifier
    Utils --> CoverageCalculator
    Utils --> Reporter
```

## Initialization Order

1. `Logger` initialization
2. `CommandLineParser` parses arguments
3. `ConfigManager` loads and validates configuration
4. `SourceManager` collects source files
5. `ASTAnalyzer` analyzes the AST of collected files
6. `LogIdentifier` identifies log functions in the AST
7. `CoverageCalculator` calculates coverage metrics
8. `Reporter` generates the final report

See [src/main.cpp](mdc:src/main.cpp) for the full initialization flow.
```

```
.cursor/rules/utility-modules.mdc
---
description: Utility modules and their usage
globs: ["src/utils/*.cpp", "include/dlogcover/utils/*.h"]
alwaysApply: true
---
# Utility Modules

The DLogCover project includes several utility modules that provide commonly used functionality:

## File Utilities

The `file_utils` module provides file system operations:
- File existence checks
- Directory operations
- File reading/writing
- Path manipulation

See [file_utils.h](mdc:include/dlogcover/utils/file_utils.h) and [file_utils.cpp](mdc:src/utils/file_utils.cpp)

## String Utilities

The `string_utils` module provides string manipulation functions:
- String splitting/joining
- Case conversion (upper/lower)
- Trimming
- String formatting

See [string_utils.h](mdc:include/dlogcover/utils/string_utils.h) and [string_utils.cpp](mdc:src/utils/string_utils.cpp)

## Logging Utilities

The `log_utils` module provides a thread-safe logging system:
- Multiple log levels (DEBUG, INFO, WARNING, ERROR, FATAL)
- Console and file output
- Formatted logging

Usage pattern:
```cpp
// Initialize logger
utils::Logger::init("app.log", true, utils::LogLevel::INFO);

// Log messages
LOG_INFO("Application started");
LOG_DEBUG("Debug information");
LOG_ERROR("Error occurred");
LOG_INFO_FMT("Found %d files", fileCount);

// Shutdown logger
utils::Logger::shutdown();
```

See [log_utils.h](mdc:include/dlogcover/utils/log_utils.h) and [log_utils.cpp](mdc:src/utils/log_utils.cpp)
```

---

